# utils/parse_area_boundaries.py
# Updated by Claude AI on 2025-10-17
#
# Script to convert the area boundaries from KML to GeoJSON format.
# Automatically calculates map center, bounds, and zoom level from coordinates.
# This script was generated by Claude.ai
# This script only needs to be run once (ever) and is not needed
# if static/data/area_boundaries.json exists.
#
# Usage:
#   python parse_area_boundaries.py input.kml
#   python parse_area_boundaries.py input.kml --output custom_output.json
#
import xml.etree.ElementTree as ET
import json
import re
import argparse
import os
import sys


def extract_area_code(name):
    """
    Extract area code from placemark name using multiple patterns.
    Supports various naming conventions:
    - "Area A:" or "Area A -" (letter codes)
    - "1 - Name" or "2 - Name" (numeric codes at start)
    - "Area 1:" or "Area 12:" (area with numbers)
    - "B-1:", "C-2:" (sub-areas with hyphens)
    - Mixed formats

    Returns area code as string, or None if no match found.
    """
    if not name:
        return None

    # Pattern 1: "Area X:" or "Area X -" where X can include hyphens (Area C-3:)
    match = re.search(r'Area\s+([A-Z0-9]+-?[A-Z0-9]*)[\s:]', name, re.IGNORECASE)
    if match:
        return match.group(1).upper()

    # Pattern 2: "X-Y:" at start (B-1:, C-2:)
    match = re.match(r'^([A-Z0-9]+-[A-Z0-9]+)[\s:]', name, re.IGNORECASE)
    if match:
        return match.group(1).upper()

    # Pattern 3: "X - Name" where X is a number at the start
    match = re.match(r'^(\d+)\s*[-–—]', name)
    if match:
        return match.group(1)

    # Pattern 4: Just "Area X" at the start (may include hyphen)
    match = re.match(r'^Area\s+([A-Z0-9]+-?[A-Z0-9]*)', name, re.IGNORECASE)
    if match:
        return match.group(1).upper()

    # Pattern 5: Single letter or number at start followed by colon
    match = re.match(r'^([A-Z0-9]{1,3}):', name)
    if match:
        return match.group(1).upper()

    return None


def parse_kml_file(kml_file_path):
    """
    Parse KML file and extract area boundary data.
    Supports multiple naming conventions for area codes (letters, numbers, or mixed).
    Returns list of area dictionaries with coordinates in GeoJSON format.
    """
    with open(kml_file_path, 'r', encoding='utf-8') as file:
        kml_content = file.read()

    # Parse XML
    root = ET.fromstring(kml_content)

    # Define KML namespace
    ns = {'kml': 'http://www.opengis.net/kml/2.2'}

    areas = []
    skipped_placemarks = []

    # Find all Placemark elements
    for placemark in root.findall('.//kml:Placemark', ns):
        name_elem = placemark.find('kml:name', ns)
        if name_elem is None:
            continue

        name = name_elem.text
        if not name:
            continue

        # Extract area code using flexible pattern matching
        area_code = extract_area_code(name)
        if not area_code:
            skipped_placemarks.append(name)
            continue

        # Get description
        desc_elem = placemark.find('kml:description', ns)
        description = desc_elem.text if desc_elem is not None else ''

        # Clean HTML tags from description
        description = re.sub(r'<[^>]*>', '', description).strip()

        # Find polygon coordinates
        coords_elem = placemark.find('.//kml:coordinates', ns)
        if coords_elem is not None:
            coord_string = coords_elem.text.strip()
            coordinates = parse_coordinates_to_geojson(coord_string)

            # Estimate max participants based on area size and description
            max_participants = estimate_max_participants(area_code, description)

            area_data = {
                'letter_code': area_code,  # Kept as 'letter_code' for backward compatibility
                'name': name,
                'description': description,
                'max_participants': max_participants,
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': [coordinates]  # GeoJSON format
                }
            }

            areas.append(area_data)

    # Sort by area code (numeric if all numeric, otherwise alphabetic)
    def sort_key(area):
        code = area['letter_code']
        # Try to sort numerically if code is a number
        try:
            return (0, int(code))  # Numeric codes come first, sorted numerically
        except ValueError:
            return (1, code)  # Non-numeric codes come second, sorted alphabetically

    areas.sort(key=sort_key)

    # Report skipped placemarks
    if skipped_placemarks:
        print(f"\nSkipped {len(skipped_placemarks)} placemarks (no area code detected):")
        for name in skipped_placemarks[:5]:  # Show first 5
            print(f"  - {name}")
        if len(skipped_placemarks) > 5:
            print(f"  ... and {len(skipped_placemarks) - 5} more")

    return areas


def parse_coordinates_to_geojson(coord_string):
    """
    Convert KML coordinate string to GeoJSON coordinate array.
    KML format: longitude,latitude,altitude (space-separated)
    GeoJSON format: [longitude, latitude] (no altitude)
    """
    coordinates = []

    for coord in coord_string.split():
        coord = coord.strip()
        if coord:
            parts = coord.split(',')
            if len(parts) >= 2:
                lng = float(parts[0])
                lat = float(parts[1])
                coordinates.append([lng, lat])

    return coordinates


def estimate_max_participants(area_code, description):
    """
    Estimate maximum participants for each area based on size and complexity.
    These can be adjusted by administrators later.
    """
    # Default values based on typical CBC area sizes (letter codes)
    defaults = {
        'A': 15, 'B': 12, 'C': 15, 'D': 12, 'E': 18, 'F': 16,
        'G': 14, 'H': 12, 'I': 10, 'J': 12, 'K': 14, 'L': 8,
        'M': 12, 'N': 10, 'O': 12, 'P': 14, 'Q': 16, 'R': 14,
        'S': 18, 'T': 16, 'U': 14, 'V': 12, 'W': 10, 'X': 8
    }

    # Check if it's in the defaults dictionary
    if area_code in defaults:
        return defaults[area_code]

    # For numeric codes or unknown codes, return default
    return 12


def calculate_map_center_and_bounds(areas):
    """
    Calculate the center point and bounding box from all area coordinates.
    Returns dict with center [lat, lng] and bounds [[south, west], [north, east]].
    """
    all_lats = []
    all_lngs = []

    # Collect all coordinates from all areas
    for area in areas:
        coordinates = area['geometry']['coordinates'][0]
        for coord in coordinates:
            lng, lat = coord[0], coord[1]
            all_lngs.append(lng)
            all_lats.append(lat)

    if not all_lats or not all_lngs:
        # Fallback to Vancouver if no coordinates
        return {
            'center': [49.2827, -123.1207],
            'bounds': [[49.00, -123.30], [49.40, -122.80]],
            'zoom': 10
        }

    # Calculate bounds
    min_lat, max_lat = min(all_lats), max(all_lats)
    min_lng, max_lng = min(all_lngs), max(all_lngs)

    # Calculate center (simple average)
    center_lat = (min_lat + max_lat) / 2
    center_lng = (min_lng + max_lng) / 2

    # Add 10% padding to bounds for better map display
    lat_padding = (max_lat - min_lat) * 0.10
    lng_padding = (max_lng - min_lng) * 0.10

    # Calculate appropriate zoom level based on area span
    lat_span = max_lat - min_lat
    lng_span = max_lng - min_lng
    max_span = max(lat_span, lng_span)

    # Zoom level heuristic (approximate)
    if max_span > 2.0:
        zoom = 8
    elif max_span > 1.0:
        zoom = 9
    elif max_span > 0.5:
        zoom = 10
    elif max_span > 0.2:
        zoom = 11
    else:
        zoom = 12

    return {
        'center': [round(center_lat, 6), round(center_lng, 6)],
        'bounds': [
            [round(min_lat - lat_padding, 6), round(min_lng - lng_padding, 6)],  # Southwest
            [round(max_lat + lat_padding, 6), round(max_lng + lng_padding, 6)]   # Northeast
        ],
        'zoom': zoom
    }


def save_areas_to_json(areas, output_path):
    """
    Save parsed area data to JSON file for use by web application.
    Includes map configuration (center, bounds, zoom) calculated from area coordinates.
    """
    # Calculate map configuration
    map_config = calculate_map_center_and_bounds(areas)

    # Create output structure with metadata
    output_data = {
        'map_config': map_config,
        'areas': areas
    }

    with open(output_path, 'w', encoding='utf-8') as file:
        json.dump(output_data, file, indent=2, ensure_ascii=False)

    print(f"Saved {len(areas)} areas to {output_path}")
    print(f"Map center: {map_config['center']}")
    print(f"Map bounds: {map_config['bounds']}")
    print(f"Suggested zoom: {map_config['zoom']}")


def generate_area_summary(areas):
    """
    Generate summary statistics about the parsed areas.
    """
    total_max = sum(area['max_participants'] for area in areas)

    print(f"\nArea Summary:")
    print(f"Total areas: {len(areas)}")
    print(f"Total maximum participants: {total_max}")
    print(f"Average max per area: {total_max / len(areas):.1f}")

    print(f"\nAreas by code:")
    for area in areas:
        coord_count = len(area['geometry']['coordinates'][0])
        print(f"  {area['letter_code']}: {area['name']} "
              f"(max: {area['max_participants']}, {coord_count} boundary points)")


def generate_areas_config_file(areas, output_path):
    """
    Generate a Python configuration file for config/areas.py.
    Creates AREA_CONFIG dictionary with area metadata.
    """
    from datetime import datetime

    lines = [
        "# Updated by Claude AI on " + datetime.now().strftime('%Y-%m-%d'),
        "# Area configuration - generated from KML parsing",
        "# Copy this content to config/areas.py or use as reference",
        "AREA_CONFIG = {"
    ]

    for area in areas:
        code = area['letter_code']
        name = area['name']
        description = area.get('description', '')

        # Try to infer difficulty and terrain from name/description
        # These are defaults and should be reviewed/customized
        difficulty = 'Easy'  # Default
        terrain = 'Mixed terrain'  # Default

        # Basic heuristics for terrain/difficulty
        name_lower = name.lower()
        if 'mountain' in name_lower or 'hill' in name_lower:
            difficulty = 'Moderate'
            terrain = 'Mountainous, trails'
        elif 'marsh' in name_lower or 'wetland' in name_lower or 'bog' in name_lower:
            difficulty = 'Moderate'
            terrain = 'Wetland, marshes'
        elif 'island' in name_lower:
            terrain = 'Island, agricultural'
        elif 'coast' in name_lower or 'beach' in name_lower or 'shore' in name_lower:
            terrain = 'Coastal, beaches'
        elif 'urban' in name_lower or 'downtown' in name_lower or 'city' in name_lower:
            terrain = 'Urban, residential'
        elif 'farm' in name_lower or 'agricultural' in name_lower:
            terrain = 'Agricultural, rural'
        elif 'richmond' in name_lower or 'delta' in name_lower or 'ladner' in name_lower:
            terrain = 'Suburban, agricultural'

        lines.append(f"    '{code}': {{")
        lines.append(f"        'name': '{name}',")
        lines.append(f"        'description': '{description}',")
        lines.append(f"        'difficulty': '{difficulty}',")
        lines.append(f"        'terrain': '{terrain}',")
        lines.append(f"        'admin_assignment_only': False")
        lines.append(f"    }},")

    lines.append("}")
    lines.append("")
    lines.append("")
    lines.append("def get_area_info(letter_code):")
    lines.append('    """Get configuration info for a specific area."""')
    lines.append("    return AREA_CONFIG.get(letter_code.upper(), {")
    lines.append("        'name': f'Area {letter_code}',")
    lines.append("        'description': 'Area description not available',")
    lines.append("        'difficulty': 'Unknown',")
    lines.append("        'terrain': 'Unknown'")
    lines.append("    })")
    lines.append("")
    lines.append("")
    lines.append("def get_all_areas():")
    lines.append('    """Get list of all available area codes."""')
    lines.append("    return sorted(AREA_CONFIG.keys())")
    lines.append("")
    lines.append("")
    lines.append("def get_public_areas():")
    lines.append('    """Get list of area codes available for public registration (excludes admin-only areas)."""')
    lines.append("    return sorted([code for code, config in AREA_CONFIG.items()")
    lines.append("                   if not config.get('admin_assignment_only', False)])")
    lines.append("")

    with open(output_path, 'w', encoding='utf-8') as f:
        f.write('\n'.join(lines))

    print(f"\nGenerated Python config: {output_path}")
    print("NOTE: Review and customize the 'difficulty' and 'terrain' values as needed.")


# Main execution script for one-time KML parsing
if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description='Parse KML file and convert area boundaries to GeoJSON format with map configuration',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python parse_area_boundaries.py "Vancouver CBC Areas.kml"
  python parse_area_boundaries.py "Ladner CBC with Area Zones.kml"
  python parse_area_boundaries.py "Fraser Estuary KBA eBird Survey.kml" --output kba_boundaries.json
  python parse_area_boundaries.py input.kml -o ../static/data/area_boundaries.json
        """
    )

    parser.add_argument(
        'kml_file',
        help='Path to the KML file containing area boundaries'
    )

    parser.add_argument(
        '-o', '--output',
        default='../static/data/area_boundaries.json',
        help='Output JSON file path (default: ../static/data/area_boundaries.json)'
    )

    args = parser.parse_args()

    try:
        # Validate input file exists
        if not os.path.exists(args.kml_file):
            print(f"Error: KML file not found: {args.kml_file}")
            print("Please check the file path and try again.")
            sys.exit(1)

        print(f"Parsing KML file: {args.kml_file}")
        print(f"Output will be saved to: {args.output}")
        print()

        # Create output directory if it doesn't exist
        output_dir = os.path.dirname(args.output)
        if output_dir and not os.path.exists(output_dir):
            os.makedirs(output_dir)
            print(f"Created directory: {output_dir}")

        # Parse and save
        all_areas = parse_kml_file(args.kml_file)

        if not all_areas:
            print("\nWarning: No areas were extracted from the KML file.")
            print("Check that the file contains Placemark elements with recognizable area codes.")
            sys.exit(1)

        # Filter to main areas only (exclude sub-areas with hyphens like B-1, C-2)
        original_count = len(all_areas)
        areas = [area for area in all_areas if '-' not in area['letter_code']]
        filtered_count = original_count - len(areas)

        if filtered_count > 0:
            print(f"Filtered out {filtered_count} sub-areas (keeping {len(areas)} main areas only)")
            print()

        if not areas:
            print("\nWarning: No main areas found (all areas were sub-areas).")
            print("If you need sub-areas, modify the filtering logic in the script.")
            sys.exit(1)

        # Generate both JSON and Python config files
        save_areas_to_json(areas, args.output)

        # Generate Python config file alongside JSON
        config_output = args.output.replace('.json', '_areas.py')
        generate_areas_config_file(areas, config_output)

        generate_area_summary(areas)

        print(f"\n{'='*60}")
        print("SUCCESS! Generated files:")
        print(f"{'='*60}")
        print(f"1. Map boundaries (JSON):  {args.output}")
        print(f"   -> Copy to: static/data/area_boundaries.json")
        print()
        print(f"2. Area configuration (Python):  {config_output}")
        print(f"   -> Review/customize difficulty and terrain values")
        print(f"   -> Copy to: config/areas.py")
        print(f"{'='*60}")
        sys.exit(0)

    except FileNotFoundError as e:
        print(f"File error: {e}")
        sys.exit(1)
    except ET.ParseError as e:
        print(f"Error parsing KML file: {e}")
        print("Make sure the file is valid KML format.")
        sys.exit(1)
    except Exception as e:
        print(f"Unexpected error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)